## OSI与TCP/IP各层结构，以及相关协议

OSI七层体系结构（从上到下）：

应用层，表示层，会话层，运输层，网络层，数据链路层，物理层

TCP/IP结构：

应用层，运输层，网际层，网络接口层

五层协议（采取二者优点）

应用层，运输层，网络层，数据链路层，物理层

### 应用层

任务是通过应用进程之间的交互来完成特定的网络应用。

应用层协议定义是应用进程之间的通信和交互的规则。

应用层有许多协议：

域名系统DNS：*Domain Name System*是因特网的一项核心服务，作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。

万维网的HTTP协议：*HyperText Transfer Protocol*是互联网上应用最广泛的网络协议。所有www文件都必须遵守这个标准，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。

电子邮件SMTP协议

……

### 运输层

任务是负责向两台主机进程之间的通信提供通用的数据传输服务。

应用进程利用该服务传送应用层报文。

“通用的”指的是并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。

因为一台主机可以同时运行多个线程，因此运输层有复用和分用的功能。复用是指多个应用层进程可以同时使用下面的运输层服务；分用则相反，是运输层把收到的信息分别交给上面应用层中相应的进程。

**两个运输层协议**：

1. 传输控制协议**TCP**(*Transmission Control Protocol*):提供面向连接的，可靠的数据传输服务
2. 用户数据协议**UDP**(*User Datagram Protocol*):提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）

### 网络层

在计算机网络中进行通信的两个计算机之间可能会经过多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换节点，确保数据及时传送。

在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫**IP数据报**，简称数据报

网络层中的网络，不是通常意义上的网络，而是指计算机网络体系结构模型中第三层的名称。

互联网通过大量的异构(heterogeneous)网络通过路由器(router)相互连接起来。互联网使用的网络层协议是无连接的网际协议(Intert Protocol)和许多路由选择协议，因此互联网的网络层也叫网际层或者IP层。

### 数据链路层

*data link layer*通常简称链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。

在两个相邻接点之间传送数据时，数据链路层将网络层叫下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制等）

接收数据时，控制信息可以判断一个帧是从哪个比特开始到哪个比特结束。这样数据链路层接收到一个帧后，可以提取相应的数据部分，上交网络层。

控制信息还使接收端能够检测到所收到的帧中有无差错。如果有，数据链路层就会丢弃这个差错帧，以避免继续在网络中白白浪费资源。如果需要改正差错，那么就要采用可靠性传输协议来纠正出现的差错，这会使得链路层协议更复杂。

### 物理层

*physical layer*的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的链路层不必考虑网络的具体传输介质是什么。

最著名的是TCP/IP协议，但是不单单是这两个协议，而是表示互联网使用的整个TCP/IP协议族

![image-20211230110035643](/Users/yangmao/Library/Application Support/typora-user-images/image-20211230110035643.png)

## **TCP三次握手和四次挥手**⭐️

为了准确无误的把数据传送到目标，TCP才用了三次握手策略

1. 客户端发送带有SYN标志的数据报到服务端，一次握手
2. 服务端发送带有SYN/ACK标志的数据报到客户端，二次握手
3. 客户端发送带有ACK标志的数据报到服务端，三次握手

### **为什么要三次握手**

总体目的是：建立可靠的通信信道。通讯简单来说就是数据的发送与接收，而三次握手最主要的目的是双方确认自己与对方的发送与接收是正常的。

第一次握手：客户端什么都不确认；服务端确认收到对方发送正常，自己接收正常

第二次握手：客户端确认自己发送、接收都正常，对方发送、接收都正常；服务端确认了对方发送正常，自己接收正常

第三次握手：客户端确认自己发送、接收都正常，对方发送、接收都正常；服务端确认了自己发送、接收正常，客户端发送、接收正常

### 为什么要传回SYN

接收端传回发送端所发送的SYN是为了告诉发送端，接收到的确实是你发的信息，从而可以让发送端确认自己的收发和对方收发都正常。

SYN是TCP/IP建立连接时使用的握手信号。ACK是*Acknowledgement*的缩写，可以译为确认字符。

### 传了SYN为什么还要传ACK

双方通信无误必须要两者间互发消息都无误。传了SYN，证明发送方到接收方的通信通道么问题，但是接收方到发送方的通道还需要ACK信号来验证

### 四次挥手

断开一个TCP连接需要四次挥手

1. 客户端发送一个FIN，用来关闭客户端到服务器的数据传送
2. 服务器端收到这个FIN，发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号
3. 服务器关闭与客户端的链接，发送一个FIN给客户端
4. 客户端发回ACK报文确认，并将确认序号设置为收到序号加1

### 为什么要四次挥手

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有任何数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

类比为打电话，FIN类似于“我说完了”，然后进入半关闭状态（不说话了，但是可以接受），此时B回答，我知道了，但是可以继续说话，直到说完，也发一个FIN表示，“我说完了”，此时A回答，我知道了，因为A之前就进入了无话可说的半关闭状态，所以此时AB都无话可说，通话结束。

## TCP和UDP的区别

| 类型 | 特点                       | 性能                   | 应用场景                                 | 首部字节 |
| ---- | -------------------------- | ---------------------- | ---------------------------------------- | -------- |
| TCP  | 面向连接，可靠，字节流     | 传输效率慢，所需资源多 | 要求通信数据可靠（如文件传输，邮件传输） | 20-60    |
| UDP  | 无连接，不可靠，数据报文段 | 传输效率快，所需资源少 | 要求通信速度高                           | 8字节    |

UDP在传送数据之前不需要先建立连接，远地主机收到UDP报文后不需要给出任何确认，不提供可靠交付，但是在某些情况下（即时通信，直播等），UDP是一种有效的工作方式

TCP提供面向连接的服务。在传送数据之前先建立连接，数据传送结束后要释放连接。由于要提供可靠的，面向连接的传输服务，难以避免的会增加许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP一般用于文件传输、发送和接收邮件、远程登录等场景。

## TCP协议如何保证可靠传输

1. 应用数据被分割成TCP认为最适合发送的数据块
2. TCP给发送的每个包编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和**。TCP将保持它首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中传输过程中的任何变化，如果收到段校验和有差错，TCP将会丢弃这个报文段和不确认收到此报文段。
4. TCP的接收端会丢弃重复的数据
5. **流量控制**：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理时，能提示对方降低发送速率防止丢包。
6. **拥塞控制**：当网络拥塞时，减少数据发送
7. **ARQ协议**：也是为了实现可靠传输的，它的基本原理是每发完一个分组就停止发送，等待对方确认，收到确认后再发下一个分组
8. **超时重传**：当TCP发出一个段后，启动一个定时器，等待目的端确认收到，如果不能及时收到，将会重发这个报文段。

## ARQ协议

自动重传请求(*Auto Repeat-reQuest*)是OSI模型中数据链路层和传输层的错误纠正协议之一。通过确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间内没有收到确认帧，就会从新发送。ARQ包括停止等待ARQ协议和连续ARQ协议

### 停止等待ARQ协议

基本原理：每发完一个分组就停止发送，等待对方确认（回复ACK），如果超时没收到，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。如果接收方收到重复分组，就该丢弃该分组，但是同时还要发送确认。

优点：简单

缺点：信道利用率低，等待时间长

几种场景：

1. 无差错情况
2. 出现差错情况（超时重传）
3. 确认（ACK）丢失
4. 确认（ACK）迟到

### 连续ARQ协议

发送方维持一个发送窗口，凡是位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明这个分组为止的所有分组都已经正确收到了。

优点：信道利用率高，容易实现，即使确认丢失也不必重传

缺点：不能向发送方反映出接收方已经正确收到的所有分组信息。假设发送发发了5个消息，中间第3条丢失，其他都收到了，但是对于发送方，只知道前两天收到了，所以会从第三条开始往后的全部发送一遍。这个过程叫做回退N（Go-Back-N），博爱是退回来重传已经发送过的N个消息

## 滑动窗口和流量控制

TCP利用滑动窗口实现流量控制。流量控制是为了控制发送方的发送速率，保证接收方来得及接收。

## 拥塞控制

拥塞：在某短时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变坏。

拥塞控制目的：防止过多数据注入到网络中，可以使网络中的路由器或链路不至于过载

拥塞控制是一个全局过程，涉及到所有主机，所有路由器以及与降低网络传输性能有关的所有因素。

为了进行拥塞控制，TCP发送方要维持一个拥塞窗口的状态变量。该窗口大小取决于网络拥塞程度，并且动态变化。

四种算法

1. 慢开始
2. 拥塞避免
3. 快重传
4. 快恢复

## 在浏览器中输入url地址 -->显示主页的过程

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面并显示
6. 连接结束

## 状态码

| 状态码 | 类别                             | 原因短语                   |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重新定向码）        | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求错误         |

## HTTP的长连接和短连接

在HTTP/1.0中默认短连接，即每进行一次HTTP操作，就建立一次连接，任务结束就中断。

客户端浏览器想要访问某个HTML或者其他类型的Web资源，每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1开始，默认使用长连接，使用长连接的HTTP协议，头部会增加`Connection:keep-alive`

长连接情况下，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这个连接。这个连接持续的时间不是永久，可以在不同的服务器软件上设定这个时间

**HTTP的长连接短连接，实际上是用于传输HTTP数据的TCP的长连接和短连接**

## HTTP不是保存状态的协议，如何保存用户状态

HTTP本身不保存状态，是无状态协议。

Session机制就是为了解决这个问题而存在的。HTTP本身无状态，但是服务器端给特定的用户或者信息创建特定的Session，之后就根据这个标志来追踪相应的信息，以达到保存状态的效果。

服务器端保存Session的方法很多，最常用的是内存和数据库。用于追踪服务器端的Session，大部分情况下，是通过在Cookie中附加一个Session ID来完成。

如果Cookie被禁用，最常用的方法是利用URL重写把Session ID直接附加在URL路径后面

## Cookie的作用以及和Session的区别

二者都是用于跟踪浏览器用户身份的会话方式，但是应用场景不太一样。

Cookie一般用来保存用户信息。（典型的是保存用户登录信息以维持登录）Cookie数据保存在客户端

Session的主要作用是通过服务端记录用户的状态。（典型的是购物车）Session数据保存在服务器端。

相对来说，Session安全性更高。如果要在Cookie中存放重要信息，一般不直接写入，而是加密，再到服务器端解密。

## HTTP1.0和HTTP1.1的区别

1. 长连接与短连接：1.0默认短连接，而1.1默认长连接。HTTP1.1的持续连接有非流水线方式和流水线方式
2. 错误状态响应码：HTTP1.1中新增了24个错误状态响应码
3. 缓存处理：1.0利用header信息进行缓存判断。而1.1则引入了更多的缓存控制策略。
4. 带宽优化及网络连接的使用。

## URL和URI的区别

URI(*Uniform Resource Identifier*)统一资源标志符，可以唯一标识一个资源

URL(*Uniform Resource Location*)统一资源定位符，可以提供该资源的路径。是一种具体的URI，即不光标识了一个资源，还知名了如果定位这个资源

## HTTP与HTTPS的区别

1. 端口：HTTP的URL由http://开头且默认使用端口80，而HTTPS的URL由https://开头且默认使用端口443

2. 安全性和资源消耗。

   * HTTP协议运行在TCP上，所有传输的内容都是明文，客户端和服务器端无法验证对方身份。
   * HTTPS是运行在SSL/TLS之上的HTTP协议，而SSL/TLS运行在TCP上，所有的传输内容都经过加密，加密采用对称加密算法，但对称加密的密钥用在服务器方的整数进行了非对称加密

   所以，HTTP的安全性没有HTTPS高，但是HTTPS比HTTP耗费了更多的服务器资源

