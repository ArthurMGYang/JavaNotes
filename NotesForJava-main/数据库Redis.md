## Redis简述

Redis是使用C语言开发的数据库，数据是存在内存中的，所以读写速度非常快，所以Redis经常被用于缓存方向。

另外，Redis也经常用来做分布式锁，甚至是消息队列

Redis提供了多种数据类型来支持不同的业务场景。还支持事务，持久化，Luau脚本，多种集群方案。

### 分布式缓存常见技术

分布式缓存使用比较多的是Memcached和Redis。不过现在更多的是Redis。

分布式缓存主要解决的是单机缓存的容量受到服务器限制并且无法保存通用的信息。因为本地缓存只在当前服务器有效。

#### Redis和Memcached异同

相同点：

1. 都是基于内存的数据库，一般都用来当做缓存使用
2. 都有过期策略
3. 两者的性能都非常高

不同点：

1. **Redis支持更丰富的数据类型**
2. **Redis支持数据的持久化**，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而Memcache的数据全部在内存中。因此，**Redis有灾难恢复机制**
3. Redis在服务器内存用完后，可以将不用的数据放在磁盘上。而Memcached内存用完会报异常
4. Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是Redis目前是原生支持cluster模式的
5. Memcached是多线程、非阻塞IO复用的网络模型；Redis是单线程的多路IO复用模型
6. Redis支持发布订阅模型、Luau脚本、事务等功能，还支持更多的编程语言；而Memcached不支持
7. Memcached过期数据的删除策略只用了惰性删除，而Redis同时使用了惰性删除与定期删除

### 缓存数据的处理流程

1. 用户发出请求

2. 检查缓存中是否存在对应的数据

   2.1 如果有，则直接返回数据

   2.2 如果没有，则进入第三步检查

3. 检查数据库中是否有对应的数据

   3.1 如果没有，返回空数据

   3.2 如果有，则进入第四步

4. 更新缓存中的数据，并返回对应的数据

### 为什么要用Redis/缓存？

简单来说是为了提升用户体验以及应对更多的用户。

可以分为高性能和高并发两点

1. 用户第一次访问数据，过程较慢，因为从硬盘读取。但是如果将高频数据放入缓存，下一次访问就可以快速获取，性能提高。不过需要注意缓存中数据和数据库中的一致性

2. 像MySQL这样的数据库QPS(Query Per Seconds服务器每秒可执行的查询次数)是1w左右，而Redis可以达到10w甚至30w。

   所以直接操作缓存能够承受的数据库请求数量是远大于直接访问数据库的。将部分数据移到缓存中去，一部分用户的请求就不需要经过数据库，从而整个系统的整体并发提高

### Redis常见数据结构

#### string

string数据结构是简单的key-value类型，虽然Redis是用C语言写的，但是Redis没有用C语言的 字符串，而是自己构建了一种简单动态字符串(SDS)。优点在于不光可以保存文本数据，还可以保存二进制数据，并且获取字符串长度的复杂度为O(1)(C语言字符串为O(N))，除此之外，SDS还是API安全的，不会造成缓冲区溢出

应用场景：需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等

#### list

链表。是一种常见的数据结构，特点是易于数据元素的插入和删除并且可以灵活调整链表长度，但是链表的随机访问困难。C语言没有像Java那样内置链表，所以Redis实现了自己的链表，是一个双向链表，更方便操作但是带来了额外的内存开销

应用场景：发布与订阅或者说队列消息、慢查询

#### hash

类似于JDK8之前的HashMap，内部实现也差不多（数组+链表）不过Redis的hash做了很多优化。hash是string类型的field和value的映射表，适合用于存储对象

应用场景：系统中对象数据的存储

#### set

类似Java中的HashSet。set是一种无序不重复的集合，提供了判断某个成员是否在set内的接口(list没有)。可以基于set轻易实现交集、并集和差集的操作。（例如共同关注，共同粉丝）

应用场景：需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景

#### sorted set

相比于set多了个权重参数score，使得集合中的元素能按照score进行有序排列，还可以通过score的范围来获取元素的列表，类似Java中HashMap和TreeSet的结合体

应用场景：需要对数据根据某个权重进行排序的场景。

## Redis单线程模型

Redis基于Reactor模式来设计开发了自己一套高效的事件处理模型，对应的是Redis中的文件事件处理器(File Event Handler)。由于文件事件处理器是单线程的，所以Redis也是的单线程的。

### 单线程的Redis如何监听大量的客户端连接

通过IO多路复用程序来监听来自客户端的大量连接(或者说是监听多个socket)，它会将感兴趣的事件及类型注册到内核中并监听每个事件是否发生。

好处：IO多路复用技术让Redis不需要创建多余的线程来监听客户端的大量连接，降低了资源的消耗。

Redis服务器是一个事件驱动程序，服务器需要处理1. 文件事件 2. 时间事件

时间事件一般不需要了解

文件事件主要包含4个部分：

1. 多个socket(客户端连接)
2. IO多路复用程序（支持多个客户端连接的关键）
3. 文件事件分派器（将socket关联到相应的事件处理器）
4. 事件处理器（连接应答处理器、命令处理器、命令回复处理器）

### 为什么Redis不适用多线程

虽然Redis是单线程模型，但是4.0还是加入了多线程支持，虽然只针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来异步处理

所以总体上Redis6.0之前都是单线程

为什么不多线程：

1. 单线程编程容易且方便维护
2. Redis的性能瓶颈不再是CPU，而是内存和网络
3. 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能

### Redis6.0为什么又引入多线程

主要目的是提高网络IO读写性能。

虽然引入了多线程，但只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程。而且Redis6.0默认禁用多线程，需要开启，开启后还需要设置线程数，否则不生效。

## Redis缓存数据的过期

### 为什么要设置缓存数据过期时间

因为内存是有限的，如果缓存中的数据都是一直保存的话，会出现out of memory

除了字符串类型有独有的的设置过期时间命令`setex`之外，其他数据类型都是靠`expire`命令来设置过期时间。`persist`命令可以移除一个键的过期时间。

除了缓解内存消耗，过期时间的还有其他作用。某些业务场景需要某个数据只在某一段时间内有效，例如验证码1分钟内有效。

### Redis如何判断数据是否过期

Redis通过一个叫做过期字典（可以看做hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个键，值是一个long型的整数，保存了key所指向的数据库建过期时间

### 过期数据的删除策略

1. 惰性删除：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期key没有被删除
2. 定期删除：每隔一段时间抽取一批key执行删除过期key操作。并且Redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

惰性删除对CPU好，而定期删除对内存好。所以Redis采用的是定期+惰性删除方式。

### Redis内存淘汰机制

（还有一种问法，MySQL里面有2000w数据，Redis只有20w，如何保证Redis数据都是热点数据）

上述两种删除方式还会漏掉许多过期的key，所以大量key还是会在内存中，为了解决这个问题，就引入了Redis内存淘汰机制。

1. volatile-lru(least recently used):从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
2. volatile-ttl:从已设置过期时间的数据集中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集中任意挑选数据淘汰
4. allkeys-lru：当内存不足写入新的时，在键空间中移除最近最少使用的key（最常用）
5. allkeys-random:从数据集中任意挑选淘汰
6. no-evicition：禁止驱逐数据，当内存不足写入新数据时，会报错（没人用这个机制）

4.0 版本后新增两个机制

7. volatile-lfu(least frequently used)：从已设置过期时间的数据集中挑选最不经常用的淘汰
8. allkeys-lfu：当内存不足以写入新数据时，在键空间中移除最不常使用的key

## Redis持久化机制

（挂掉重启后数据怎么恢复）

要持久化就是将内存数据写入硬盘中。或者是为了防止系统故障而将数据备份到一个远程位置。

### 快照持久化(snapshotting RDB)

Redis通过创建快照来获得存储在内存里面的数据在某个时间点的副本。可以将快照发到其他服务器从而创建相同数据的服务器副本，或者保留在原地以便服务器重启的时候使用

#### 只追加文件(append-only file AOF)持久化

实时性相对更好，是目前主流方案。开启AOF持久化之后每执行一条会更改Redis中数据的命令，Redis就会将该命令写入磁盘中的AOF文件。AOF文件位置和RDB相同。

Redis有是那种AOF持久化方式

1. always 每次修改都会写入，降低Redis速度
2. everysec每秒同步一次，显示地将多个写命令同步到硬盘
3. no让系统决定何时进行同步

### Redis4.0对持久化优化

4.0开始RDB和AOF混合持久化。AOF重写的时候会直接把RDB的内容写到AOF的开头，可以结合RDB和AOF的优点，快速加载同时避免丢失过多的数据，缺点是AOF里面的RDB部分压缩格式不是AOF格式，可读性差。

## Redis事务

通过`MULTI, EXEC, DISCARD, WATCH`等命令实现事务功能

但是Redis事务和平时理解的不同，事务的四大特性1.原子性2.隔离性3.持久性4.一致性。Redis并不都满足。

Redis不支持roll back，因而不满足原子性和持久性

Redis事务可以理解为：Redis事务提供了一种将多个命令请求打包的功能。然后再按照顺序执行打包的所有命令，并且不会被中途打断。

## 缓存穿透

缓存穿透是大量请求的key不在缓存中，导致请求直接到了数据库上，没有经过缓存这一层。

具体流程

用户请求----->缓存中不存在对应数据---N---->数据库中是否存在对应数据----N--->返回空数据

### 解决方案

基础的方法是参数校验，将不合法的请求抛出异常（例如id不能小于0）

1. 缓存无效key。如果缓存和数据库中都没有某个key，就写一个到Redis中去并设置一个过期时间。

2. 布隆过滤器。它是一个神奇的数据结构，通过它可以方便的判断一个给定的数据是否存在于海量数据中。

   具体的做法是：把所有可能的请求的值都放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器，不存在的话，直接返回请求参数错误信息给客户端，存在的话再进入缓存及数据库查找流程。但是布隆过滤器会出现误判的情况，即它说存在，可能是误判，但是它说不存在，一定是不存在。

## 缓存雪崩

### 概念

缓存雪崩是一个场景：缓存在同一时间大面积的失效，或者大量的访问数据在某一时刻大面积失效，后面的请求直接落在了数据库上，造成数据库短时间内承受大量的请求。

### 解决方案

针对Redis服务不可用

1. 采用Redis集群，避免单机出现问题整个缓存服务都没法使用
2. 限流，避免同时处理大量的请求

针对热点缓存失效

1. 设置不同的失效时间比如随机设置缓存的失效时间
2. 缓存永不失效

## 如何保证缓存和数据库的一致性

旁路缓存模式(Cache Aside Pattern)

遇到写请求时，该模式的处理是：更新DB，然后直接删除cache

如果数据库更新成功，而删除缓存这一部失败的话，有两个解决方案

1. 缓存失效时间变短（治标不治本）
2. 增加cache更新重试机制（常用）



